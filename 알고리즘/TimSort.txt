
timsort

소개
Timsort는 2002에 Tim Peters가 개발했습니다. Python, java SE7, swift 등에서 정렬 알고리즘으로 사용됩니다. 병합 정렬(Merge Sort), 삽입 정렬(Insertion Sort) 두가지 정렬을 사용하며 하이브리드 방식으로 효율적으로 정렬합니다. 부분적으로 자연스럽게 정렬된 데이터를 사용하여 효과적으로 정렬할 수 있는 장점을 갖고 있는 알고리즘입니다.

Timsort의 장점과 단점
장점
실제 데이터에서 뛰어난 성능: Timsort는 자연스럽게 정렬된 데이터를 찾고 활용하기 때문에, 많은 실제 데이터에서 퀵정렬보다 빠르게 동작할 수 있습니다.

안정적인 정렬: 동일한 값에서 상대적인 순서로 저장되서 데이터를 정렬 한 후에도 원래의 순서를 유지해야 하는 경우에 유용합니다.

최적의 병합 전략: 병합 순서를 조정하고 최소한의 병합을 수행함으로써 불필요한 연산을 줄입니다.

단점
최악의 경우 추가 메모리 사용: Timsort는 병합 정렬을 기반이기때문에 경우에 따라 추가적인 메모리가 필요할 수 있습니다.

간단한 구현이 아님: 퀵정렬이나 삽입 정렬보다 알고리즘이 복잡하여 직접 구현하기 어려울 수 있습니다.

Timsort는 삽입 정렬 + 병합 정렬 + 최적화 기법을 결합한 정렬 알고리즘으로 실제 데이터에서 뛰어난 성능을 발휘합니다.
Python을 포함한 다양한 언어에서 사용되고 있으며 특히 대규모 데이터 정렬에서 안정성과 효율성을 제공하는 알고리즘입니다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

1. Timsort의 핵심 개념

1.1 런 찾기
주어진 배열에서 어느정도 정렬된 부분을 찾습니다. 오름차순 또는 내림차순으로 정렬된 연속된 요소들을 런이라고 합니다.
오름차순으로 정렬된 부분은 그대로 유지합니다.
내림차순으로 정렬된 부분은 뒤집어서 오름차순으로 변환합니다.
Timsort는 이러한 런들을 적절히 병합하여 전체 정렬을 수행합니다.

1.2 최소한의 런 설정하기
병합 정렬과 삽입 정렬을 효과적으로 활용하기 위해 최소한의 런을 설정하여 나눠야합니다.
2의 지수승이 병합정렬로 정렬하기가 쉽고 사입 정렬의 경우에도 데이터가 작을수록 최대 성능을 냅니다.
minrun은 32~64 사이의 값으로 결정해야하고 일반적으로 주어진 배열 크기를 확인하고 동적으로 설정됩니다.
minrun의 개수보다 작은 크기의 배열은 이진 삽입 정렬을 사용하여 정렬됩니다.
minrun 이상의 크기의 런은 병합 정렬을 통해 정렬됩니다.
minrun을 적절하게 설정하면 병합 횟수를 줄이고 삽입 정렬을 효과적으로 사용할 수 있기때문에 전체적인 성능이 향상됩니다.

1.3 병합 순서 결정
병합을 수행할 때 런의 길이를 고려하여 병합 순서를 결정합니다.
병합 규칙:
최근 3개의 런 A, B, C에 대해 A > B + C 및 B > C를 만족해야 합니다.
만약 A ≤ B + C라면, 더 작은 런을 우선적으로 병합합니다.
병합 후에도 규칙을 만족하는지 확인하고, 만족하지 않는다면 추가적으로 병합을 수행합니다.
이 규칙을 사용하면 병합 균형을 맞추면서도 병합 횟수를 최소화할 수 있습니다.

1.4 병합 메모리 결정
두 run 중에 크기가 작은 run을 다른 메모리에 복사를 합니다.
앞의 run이 크면 앞에서부터 병합하며 값을 채워넣고 뒤의 run이 크면 뒤에서부터 병합하며 데이터에 손상이 없도록 합니다.
크기가 작은 run의 메모리를 복사함으로써 추가 메모리를 최소한으로 사용할 수 있게 됩니다.


1.5 갈로핑(Galloping) 모드
병합을 수행할 때, 특정한 상황에서는 갈로핑 모드를 활성화합니다.

일반적인 병합 정렬은 한 번에 하나씩 값을 비교하고 정렬합니다.
하지만 Timsort는 같은 배열에서 계속적으로 비교 연산이 발생한다면 이진 검색을 사용해서 더 빠르게 위치를 찾을 수 있는 기법을 사용합니다.
이것이 갈로핑 모드이고, 특정한 임계값 이상으로 같은 배열에서 계속된 값이 선택되면 활성화됩니다.
갈로핑 모드는 중복된 값이 많거나 한쪽 배열이 다른 쪽보다 훨씬 클 때 유용하게 사용됨으로써 불필요한 비교 연산을 줄이고 성능을 향상할 수 있습니다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

2. Timsort의 동작 과정
2.1 런 찾기
입력 배열에서 자연스럽게 정렬된 런을 찾고, 내림차순으로 정렬된 런은 뒤집습니다.

2.2 최소 런 결정
배열 크기에 따라 적절한 최소 런을 설정합니다.

2.3 삽입 정렬
minrun 이하의 작은 런은 삽입 정렬을 사용하여 개별적으로 정렬됩니다.

2.4 병합 수행
병합 규칙에 따라 인접한 런들을 병합합니다.
갈로핑 모드를 사용하여 최적의 성능을 유지합니다.
모든 런이 병합되면 최종적으로 정렬이 완료됩니다.





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


3. Timsort의 성능 분석
3.1 시간 복잡도
데이터 상태	최선의 경우	평균적인 경우	최악의 경우
거의 정렬된 데이터	O(n)	O(n log n)	O(n log n)
최선의 경우 O(n): 입력 데이터가 이미 정렬된 경우, Timsort는 대부분의 병합을 건너뛸 수 있습니다.
평균적인 경우 O(n log n): 대부분의 정렬되지 않은 데이터는 병합 정렬의 복잡도를 따릅니다.
최악의 경우 O(n log n): 완전히 무작위 데이터에서는 표준 병합 정렬과 동일한 성능을 보입니다.


3.2 공간 복잡도
Timsort는 O(n)의 보조 메모리를 사용할 수 있지만, 일반적으로 O(log n) 수준의 추가 메모리를 활용하여 병합을 수행합니다.

성능
Timsort는 데이터 안에서 자연스럽게 정렬된 부분(run)을 확인하고 이 부분을 기반으로 정렬합니다. 여기서 최적의 병합 전략을 사용하여 **O(n log n)**의 시간 복잡도를 유지하면서도, 일부 정렬된 데이터에서는 **O(n)**에 가까운 성능을 발휘합니다.
